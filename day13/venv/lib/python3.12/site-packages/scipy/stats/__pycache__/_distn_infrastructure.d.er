##[pylyzer] failed /home/dani/advent-of-code-2024/day13/venv/lib/python3.12/site-packages/scipy/stats/_distn_infrastructure.py 1734628983 150082
.___v_desugar_1 = pyimport "_util"
._util = pyimport "_util"
._getfullargspec: (func: Obj) -> Never
.sys = pyimport "<failure>"
.<failure> = pyimport "<failure>"

.keyword = pyimport "<failure>"


.re = pyimport "<failure>"


.types = pyimport "<failure>"


.warnings = pyimport "<failure>"


.___v_desugar_2 = pyimport "<failure>"

.zip_longest: Never
.doccer = pyimport "doccer"

.___v_desugar_3 = pyimport "_distr_params"
._distr_params = pyimport "_distr_params"
.distcont: global::List!(global::List!({"rayleigh"} or {"moyal"} or {"dgamma"} or {"exponnorm"} or global::Tuple([{0.4141193182605212}]) or global::Tuple([{2.621716532144454}]) or {"levy_stable"} or {"loguniform"} or {"genlogistic"} or {"levy"} or {"genhyperbolic"} or {"burr12"} or {"arcsine"} or {"dweibull"} or {"loggamma"} or {"weibull_max"} or {"vonmises_line"} or {"powerlaw"} or {"hypsecant"} or {"kappa4"} or {"truncpareto"} or {"lomax"} or {"gumbel_r"} or {"norminvgauss"} or {"anglit"} or {"wald"} or {"truncnorm"} or {"chi"} or {"kstwobign"} or {"logistic"} or {"genhalflogistic"} or {"trapezoid"} or {"bradford"} or {"laplace"} or {"vonmises"} or {"genexpon"} or {"cosine"} or {"gennorm"} or {"foldcauchy"} or {"jf_skew_t"} or {"powernorm"} or {"semicircular"} or {"cauchy", "tukeylambda", "wrapcauchy"} or {"johnsonsu"} or {"recipinvgauss"} or {"maxwell"} or {"betaprime"} or {"beta"} or {"truncweibull_min"} or {"gengamma"} or {"ksone"} or {"invgamma"} or {"halfgennorm"} or {"fisk"} or {"rice"} or {"burr"} or {"exponweib"} or {"genextreme"} or {"halfnorm"} or {"loglaplace"} or {"pearson3"} or {"foldnorm"} or {"norm"} or {"reciprocal"} or {"ncf"} or {"gausshyper"} or {"ncx2"} or {"exponpow", "levy_l", "laplace_asymmetric", "weibull_min", "rdist", "irwinhall"} or {"nct"} or {"kstwo"} or {"erlang"} or {"gompertz"} or {"powerlognorm"} or {"rel_breitwigner"} or {"skewnorm"} or global::Tuple([]) or {"geninvgauss"} or {"halflogistic"} or {"genpareto"} or {"argus"} or {"uniform"} or {"triang"} or {"lognorm"} or {"halfcauchy"} or {"fatiguelife"} or {"johnsonsb"} or {"t"} or {"f"} or {"chi2"} or {"invgauss"} or {"invweibull"} or {"mielke"} or {"pareto"} or {"studentized_range"} or {"crystalball"} or {"nakagami"} or {"gumbel_l"} or {"alpha"} or {"skewcauchy"} or {"kappa3"} or {"expon"} or {"gibrat"} or {"gamma"} or {"truncexpon"}, 2), 116)
.distdiscrete: global::List!(global::List!(global::Tuple([{0.51}]) or global::Tuple([{5}, {2.3}, {0.63}]) or {"betabinom"} or global::Tuple([{21}, {18}, {11}]) or {"bernoulli"} or {"logser"} or global::Tuple([{6.6}]) or {"nchypergeom_fisher"} or {"randint"} or {"poisson"} or {"planck"} or global::Tuple([{15}, {8}]) or {"nbinom"} or global::Tuple([{5}, {0.5}]) or {"zipf"} or {"hypergeom"} or {"zipfian"} or global::Tuple([{7}, {31}]) or {"yulesimon"} or {"nhypergeom"} or {"skellam"} or global::Tuple([{21}, {3}, {12}]) or global::Tuple([{140}, {80}, {60}, {0.5}]) or global::Tuple([{5}, {0.4}]) or {"dlaplace"} or global::Tuple([{1.25}, {10}]) or global::Tuple([{0.8}]) or global::Tuple([{1.4}, {19}]) or global::Tuple([{0.4}, {0.4}]) or global::Tuple([{0.75}, {15}]) or global::Tuple([{20}, {7}, {1}]) or {"betanbinom"} or {"geom"} or global::Tuple([{0.3}]) or {"binom"} or global::Tuple([{0.6}]) or global::Tuple([{5}, {9.3}, {1}]) or global::Tuple([{0.5}]) or global::Tuple([{11.0}]) or {"boltzmann"} or {"nchypergeom_wallenius"} or global::Tuple([{30}, {12}, {6}]), 2), 24)
.___v_desugar_4 = pyimport "_util"

.check_random_state: (seed: Obj) -> Never
.___v_desugar_5 = pyimport "__init__"
.__init__ = pyimport "__init__"
.comb: Never
.entr: Never
.optimize = pyimport "__init__"


.integrate = pyimport "__init__"


.___v_desugar_6 = pyimport "_finite_differences"
._finite_differences = pyimport "_finite_differences"
._derivative: |R <: Int, R :> Int, O :> Float, O: Type, R: Type, Type_146861 <: Structural({.__add__ = (self: Never, R) -> O})|(func: (O) -> R, x0: Type_146861, dx: R := {1.0} and R, n: {1} := {1} and {1}, args: Obj := Obj, order: {3} := {3} and {3}) -> O
.stats = pyimport "__init__"


.___v_desugar_7 = pyimport "__init__"

.arange: Never
.putmask: Never
.ones: Never
.shape: Never
.ndarray: Never
.zeros: Never
.floor: Never
.logical_and: Never
.log: Never
.sqrt: Never
.place: Never
.argmax: Never
.vectorize: Never
.asarray: Never
.nan: Never
.inf: Never
.isinf: Never
.empty: Never
.np = pyimport "__init__"


.___v_desugar_8 = pyimport "_constants"
._constants = pyimport "_constants"
._XMAX: Never
._LOGXMAX: Never
.___v_desugar_9 = pyimport "_censored_data"
._censored_data = pyimport "_censored_data"
.CensoredData: {_censored_data.CensoredData}
.___v_desugar_10 = pyimport "_warnings_errors"
._warnings_errors = pyimport "_warnings_errors"
.FitError: {_warnings_errors.FitError}
.docheaders: global::Dict!({{"methods"}: {"\nMethods\n-------\n"}, {"notes"}: {"\nNotes\n-----\n"}, {"examples"}: {"\nExamples\n--------\n"}})
._doc_rvs: {"rvs(Type_(shapes)s, loc=0, scale=1, size=1, random_state=None)\n    Random variates.\n"}
._doc_pdf: {"pdf(x, Type_(shapes)s, loc=0, scale=1)\n    Probability density function.\n"}
._doc_logpdf: {"logpdf(x, Type_(shapes)s, loc=0, scale=1)\n    Log of the probability density function.\n"}
._doc_pmf: {"pmf(k, Type_(shapes)s, loc=0, scale=1)\n    Probability mass function.\n"}
._doc_logpmf: {"logpmf(k, Type_(shapes)s, loc=0, scale=1)\n    Log of the probability mass function.\n"}
._doc_cdf: {"cdf(x, Type_(shapes)s, loc=0, scale=1)\n    Cumulative distribution function.\n"}
._doc_logcdf: {"logcdf(x, Type_(shapes)s, loc=0, scale=1)\n    Log of the cumulative distribution function.\n"}
._doc_sf: {"sf(x, Type_(shapes)s, loc=0, scale=1)\n    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n"}
._doc_logsf: {"logsf(x, Type_(shapes)s, loc=0, scale=1)\n    Log of the survival function.\n"}
._doc_ppf: {"ppf(q, Type_(shapes)s, loc=0, scale=1)\n    Percent point function (inverse of ``cdf`` --- percentiles).\n"}
._doc_isf: {"isf(q, Type_(shapes)s, loc=0, scale=1)\n    Inverse survival function (inverse of ``sf``).\n"}
._doc_moment: {"moment(order, Type_(shapes)s, loc=0, scale=1)\n    Non-central moment of the specified order.\n"}
._doc_stats: {"stats(Type_(shapes)s, loc=0, scale=1, moments=\'mv\')\n    Mean(\'m\'), variance(\'v\'), skew(\'s\'), and.or kurtosis(\'k\').\n"}
._doc_entropy: {"entropy(Type_(shapes)s, loc=0, scale=1)\n    (Differential) entropy of the RV.\n"}
._doc_fit: {"fit(data)\n    Parameter estimates for generic data.\n    See `scipy.stats.rv_continuous.fit <https:..docs.scipy.org.doc.scipy.reference.generated.scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the\n    keyword arguments.\n"}
._doc_expect: {"expect(func, args=(Type_(shapes_)s), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n    Expected value of a function (of one argument) with respect to the distribution.\n"}
._doc_expect_discrete: {"expect(func, args=(Type_(shapes_)s), loc=0, lb=None, ub=None, conditional=False)\n    Expected value of a function (of one argument) with respect to the distribution.\n"}
._doc_median: {"median(Type_(shapes)s, loc=0, scale=1)\n    Median of the distribution.\n"}
._doc_mean: {"mean(Type_(shapes)s, loc=0, scale=1)\n    Mean of the distribution.\n"}
._doc_var: {"var(Type_(shapes)s, loc=0, scale=1)\n    Variance of the distribution.\n"}
._doc_std: {"std(Type_(shapes)s, loc=0, scale=1)\n    Standard deviation of the distribution.\n"}
._doc_interval: {"interval(confidence, Type_(shapes)s, loc=0, scale=1)\n    Confidence interval with equal areas around the median.\n"}
._doc_allmethods: Str
._doc_default_longsummary: {"As an instance of the `rv_continuous` class, `Type_(name)s` object inherits from it\na collection of generic methods (see below for the full list),\nand completes them with details specific for this particular distribution.\n"}
._doc_default_frozen_note: {"\nAlternatively, the object may be called (as a function) to fix the shape,\nlocation, and scale parameters returning a \"frozen\" continuous RV object:\n\nrv = Type_(name)s(Type_(shapes)s, loc=0, scale=1)\n    - Frozen RV object with the same methods but holding the given shape,\n      location, and scale fixed.\n"}
._doc_default_example: {"Examples\n--------\n>>> import numpy as np\n>>> from scipy.stats import Type_(name)s\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)\n\nCalculate the first four moments:\n\nType_(set_vals_stmt)s\n>>> mean, var, skew, kurt = Type_(name)s.stats(Type_(shapes)s, moments=\'mvsk\')\n\nDisplay the probability density function (``pdf``):\n\n>>> x = np.linspace(Type_(name)s.ppf(0.01, Type_(shapes)s),\n...                 Type_(name)s.ppf(0.99, Type_(shapes)s), 100)\n>>> ax.plot(x, Type_(name)s.pdf(x, Type_(shapes)s),\n...        \'r-\', lw=5, alpha=0.6, label=\'Type_(name)s pdf\')\n\nAlternatively, the distribution object can be called (as a function)\nto fix the shape, location and scale parameters. This returns a \"frozen\"\nRV object holding the given parameters fixed.\n\nFreeze the distribution and display the frozen ``pdf``:\n\n>>> rv = Type_(name)s(Type_(shapes)s)\n>>> ax.plot(x, rv.pdf(x), \'k-\', lw=2, label=\'frozen pdf\')\n\nCheck accuracy of ``cdf`` and ``ppf``:\n\n>>> vals = Type_(name)s.ppf([0.001, 0.5, 0.999], Type_(shapes)s)\n>>> np.allclose([0.001, 0.5, 0.999], Type_(name)s.cdf(vals, Type_(shapes)s))\nTrue\n\nGenerate random numbers:\n\n>>> r = Type_(name)s.rvs(Type_(shapes)s, size=1000)\n\nAnd compare the histogram:\n\n>>> ax.hist(r, density=True, bins=\'auto\', histtype=\'stepfilled\', alpha=0.2)\n>>> ax.set_xlim([x[0], x[-1]])\n>>> ax.legend(loc=\'best\', frameon=False)\n>>> plt.show()\n\n"}
._doc_default_locscale: {"The probability density above is defined in the \"standardized\" form. To shift\nand.or scale the distribution use the ``loc`` and ``scale`` parameters.\nSpecifically, ``Type_(name)s.pdf(x, Type_(shapes)s, loc, scale)`` is identically\nequivalent to ``Type_(name)s.pdf(y, Type_(shapes)s) . scale`` with\n``y = (x - loc) . scale``. Note that shifting the location of a distribution\ndoes not make it a \"noncentral\" distribution; noncentral generalizations of\nsome distributions are available in separate classes.\n"}
._doc_default: Str
._doc_default_before_notes: Str
.docdict: global::Dict!({{"logcdf"}: {"logcdf(x, Type_(shapes)s, loc=0, scale=1)\n    Log of the cumulative distribution function.\n"}, {"pdf"}: {"pdf(x, Type_(shapes)s, loc=0, scale=1)\n    Probability density function.\n"}, {"after_notes"}: {"The probability density above is defined in the \"standardized\" form. To shift\nand.or scale the distribution use the ``loc`` and ``scale`` parameters.\nSpecifically, ``Type_(name)s.pdf(x, Type_(shapes)s, loc, scale)`` is identically\nequivalent to ``Type_(name)s.pdf(y, Type_(shapes)s) . scale`` with\n``y = (x - loc) . scale``. Note that shifting the location of a distribution\ndoes not make it a \"noncentral\" distribution; noncentral generalizations of\nsome distributions are available in separate classes.\n"}, {"before_notes"}: Str, {"isf"}: {"isf(q, Type_(shapes)s, loc=0, scale=1)\n    Inverse survival function (inverse of ``sf``).\n"}, {"example"}: {"Examples\n--------\n>>> import numpy as np\n>>> from scipy.stats import Type_(name)s\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)\n\nCalculate the first four moments:\n\nType_(set_vals_stmt)s\n>>> mean, var, skew, kurt = Type_(name)s.stats(Type_(shapes)s, moments=\'mvsk\')\n\nDisplay the probability density function (``pdf``):\n\n>>> x = np.linspace(Type_(name)s.ppf(0.01, Type_(shapes)s),\n...                 Type_(name)s.ppf(0.99, Type_(shapes)s), 100)\n>>> ax.plot(x, Type_(name)s.pdf(x, Type_(shapes)s),\n...        \'r-\', lw=5, alpha=0.6, label=\'Type_(name)s pdf\')\n\nAlternatively, the distribution object can be called (as a function)\nto fix the shape, location and scale parameters. This returns a \"frozen\"\nRV object holding the given parameters fixed.\n\nFreeze the distribution and display the frozen ``pdf``:\n\n>>> rv = Type_(name)s(Type_(shapes)s)\n>>> ax.plot(x, rv.pdf(x), \'k-\', lw=2, label=\'frozen pdf\')\n\nCheck accuracy of ``cdf`` and ``ppf``:\n\n>>> vals = Type_(name)s.ppf([0.001, 0.5, 0.999], Type_(shapes)s)\n>>> np.allclose([0.001, 0.5, 0.999], Type_(name)s.cdf(vals, Type_(shapes)s))\nTrue\n\nGenerate random numbers:\n\n>>> r = Type_(name)s.rvs(Type_(shapes)s, size=1000)\n\nAnd compare the histogram:\n\n>>> ax.hist(r, density=True, bins=\'auto\', histtype=\'stepfilled\', alpha=0.2)\n>>> ax.set_xlim([x[0], x[-1]])\n>>> ax.legend(loc=\'best\', frameon=False)\n>>> plt.show()\n\n"}, {"expect"}: {"expect(func, args=(Type_(shapes_)s), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n    Expected value of a function (of one argument) with respect to the distribution.\n"}, {"cdf"}: {"cdf(x, Type_(shapes)s, loc=0, scale=1)\n    Cumulative distribution function.\n"}, {"rvs"}: {"rvs(Type_(shapes)s, loc=0, scale=1, size=1, random_state=None)\n    Random variates.\n"}, {"mean"}: {"mean(Type_(shapes)s, loc=0, scale=1)\n    Mean of the distribution.\n"}, {"logpdf"}: {"logpdf(x, Type_(shapes)s, loc=0, scale=1)\n    Log of the probability density function.\n"}, {"sf"}: {"sf(x, Type_(shapes)s, loc=0, scale=1)\n    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n"}, {"var"}: {"var(Type_(shapes)s, loc=0, scale=1)\n    Variance of the distribution.\n"}, {"stats"}: {"stats(Type_(shapes)s, loc=0, scale=1, moments=\'mv\')\n    Mean(\'m\'), variance(\'v\'), skew(\'s\'), and.or kurtosis(\'k\').\n"}, {"default"}: Str, {"logsf"}: {"logsf(x, Type_(shapes)s, loc=0, scale=1)\n    Log of the survival function.\n"}, {"allmethods"}: Str, {"std"}: {"std(Type_(shapes)s, loc=0, scale=1)\n    Standard deviation of the distribution.\n"}, {"interval"}: {"interval(confidence, Type_(shapes)s, loc=0, scale=1)\n    Confidence interval with equal areas around the median.\n"}, {"ppf"}: {"ppf(q, Type_(shapes)s, loc=0, scale=1)\n    Percent point function (inverse of ``cdf`` --- percentiles).\n"}, {"frozennote"}: {"\nAlternatively, the object may be called (as a function) to fix the shape,\nlocation, and scale parameters returning a \"frozen\" continuous RV object:\n\nrv = Type_(name)s(Type_(shapes)s, loc=0, scale=1)\n    - Frozen RV object with the same methods but holding the given shape,\n      location, and scale fixed.\n"}, {"fit"}: {"fit(data)\n    Parameter estimates for generic data.\n    See `scipy.stats.rv_continuous.fit <https:..docs.scipy.org.doc.scipy.reference.generated.scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the\n    keyword arguments.\n"}, {"longsummary"}: {"As an instance of the `rv_continuous` class, `Type_(name)s` object inherits from it\na collection of generic methods (see below for the full list),\nand completes them with details specific for this particular distribution.\n"}, {"moment"}: {"moment(order, Type_(shapes)s, loc=0, scale=1)\n    Non-central moment of the specified order.\n"}, {"entropy"}: {"entropy(Type_(shapes)s, loc=0, scale=1)\n    (Differential) entropy of the RV.\n"}, {"median"}: {"median(Type_(shapes)s, loc=0, scale=1)\n    Median of the distribution.\n"}})
.docdict_discrete: global::Dict({{"logcdf"}: {"logcdf(x, Type_(shapes)s, loc=0, scale=1)\n    Log of the cumulative distribution function.\n"}, {"pdf"}: {"pdf(x, Type_(shapes)s, loc=0, scale=1)\n    Probability density function.\n"}, {"after_notes"}: {"The probability density above is defined in the \"standardized\" form. To shift\nand.or scale the distribution use the ``loc`` and ``scale`` parameters.\nSpecifically, ``Type_(name)s.pdf(x, Type_(shapes)s, loc, scale)`` is identically\nequivalent to ``Type_(name)s.pdf(y, Type_(shapes)s) . scale`` with\n``y = (x - loc) . scale``. Note that shifting the location of a distribution\ndoes not make it a \"noncentral\" distribution; noncentral generalizations of\nsome distributions are available in separate classes.\n"}, {"before_notes"}: Str, {"isf"}: {"isf(q, Type_(shapes)s, loc=0, scale=1)\n    Inverse survival function (inverse of ``sf``).\n"}, {"example"}: {"Examples\n--------\n>>> import numpy as np\n>>> from scipy.stats import Type_(name)s\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)\n\nCalculate the first four moments:\n\nType_(set_vals_stmt)s\n>>> mean, var, skew, kurt = Type_(name)s.stats(Type_(shapes)s, moments=\'mvsk\')\n\nDisplay the probability density function (``pdf``):\n\n>>> x = np.linspace(Type_(name)s.ppf(0.01, Type_(shapes)s),\n...                 Type_(name)s.ppf(0.99, Type_(shapes)s), 100)\n>>> ax.plot(x, Type_(name)s.pdf(x, Type_(shapes)s),\n...        \'r-\', lw=5, alpha=0.6, label=\'Type_(name)s pdf\')\n\nAlternatively, the distribution object can be called (as a function)\nto fix the shape, location and scale parameters. This returns a \"frozen\"\nRV object holding the given parameters fixed.\n\nFreeze the distribution and display the frozen ``pdf``:\n\n>>> rv = Type_(name)s(Type_(shapes)s)\n>>> ax.plot(x, rv.pdf(x), \'k-\', lw=2, label=\'frozen pdf\')\n\nCheck accuracy of ``cdf`` and ``ppf``:\n\n>>> vals = Type_(name)s.ppf([0.001, 0.5, 0.999], Type_(shapes)s)\n>>> np.allclose([0.001, 0.5, 0.999], Type_(name)s.cdf(vals, Type_(shapes)s))\nTrue\n\nGenerate random numbers:\n\n>>> r = Type_(name)s.rvs(Type_(shapes)s, size=1000)\n\nAnd compare the histogram:\n\n>>> ax.hist(r, density=True, bins=\'auto\', histtype=\'stepfilled\', alpha=0.2)\n>>> ax.set_xlim([x[0], x[-1]])\n>>> ax.legend(loc=\'best\', frameon=False)\n>>> plt.show()\n\n"}, {"expect"}: {"expect(func, args=(Type_(shapes_)s), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n    Expected value of a function (of one argument) with respect to the distribution.\n"}, {"cdf"}: {"cdf(x, Type_(shapes)s, loc=0, scale=1)\n    Cumulative distribution function.\n"}, {"rvs"}: {"rvs(Type_(shapes)s, loc=0, scale=1, size=1, random_state=None)\n    Random variates.\n"}, {"mean"}: {"mean(Type_(shapes)s, loc=0, scale=1)\n    Mean of the distribution.\n"}, {"logpdf"}: {"logpdf(x, Type_(shapes)s, loc=0, scale=1)\n    Log of the probability density function.\n"}, {"sf"}: {"sf(x, Type_(shapes)s, loc=0, scale=1)\n    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n"}, {"var"}: {"var(Type_(shapes)s, loc=0, scale=1)\n    Variance of the distribution.\n"}, {"stats"}: {"stats(Type_(shapes)s, loc=0, scale=1, moments=\'mv\')\n    Mean(\'m\'), variance(\'v\'), skew(\'s\'), and.or kurtosis(\'k\').\n"}, {"default"}: Str, {"logsf"}: {"logsf(x, Type_(shapes)s, loc=0, scale=1)\n    Log of the survival function.\n"}, {"allmethods"}: Str, {"std"}: {"std(Type_(shapes)s, loc=0, scale=1)\n    Standard deviation of the distribution.\n"}, {"interval"}: {"interval(confidence, Type_(shapes)s, loc=0, scale=1)\n    Confidence interval with equal areas around the median.\n"}, {"ppf"}: {"ppf(q, Type_(shapes)s, loc=0, scale=1)\n    Percent point function (inverse of ``cdf`` --- percentiles).\n"}, {"frozennote"}: {"\nAlternatively, the object may be called (as a function) to fix the shape,\nlocation, and scale parameters returning a \"frozen\" continuous RV object:\n\nrv = Type_(name)s(Type_(shapes)s, loc=0, scale=1)\n    - Frozen RV object with the same methods but holding the given shape,\n      location, and scale fixed.\n"}, {"fit"}: {"fit(data)\n    Parameter estimates for generic data.\n    See `scipy.stats.rv_continuous.fit <https:..docs.scipy.org.doc.scipy.reference.generated.scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the\n    keyword arguments.\n"}, {"longsummary"}: {"As an instance of the `rv_continuous` class, `Type_(name)s` object inherits from it\na collection of generic methods (see below for the full list),\nand completes them with details specific for this particular distribution.\n"}, {"moment"}: {"moment(order, Type_(shapes)s, loc=0, scale=1)\n    Non-central moment of the specified order.\n"}, {"entropy"}: {"entropy(Type_(shapes)s, loc=0, scale=1)\n    (Differential) entropy of the RV.\n"}, {"median"}: {"median(Type_(shapes)s, loc=0, scale=1)\n    Median of the distribution.\n"}})



._doc_disc_methods: global::List!({"isf", "interval", "sf", "median", "expect", "cdf", "std", "entropy", "logcdf", "rvs", "pmf", "ppf", "stats", "logsf", "logpmf", "var", "mean"}, 17)

._doc_disc_methods_err_varname: global::List!({"cdf", "sf", "logcdf", "logsf"}, 4)



._doc_allmethods: Never


._doc_default_frozen_note: {"\nAlternatively, the object may be called (as a function) to fix the shape and\nlocation parameters returning a \"frozen\" discrete RV object:\n\nrv = Type_(name)s(Type_(shapes)s, loc=0)\n    - Frozen RV object with the same methods but holding the given shape and\n      location fixed.\n"}

._doc_default_discrete_example: {"Examples\n--------\n>>> import numpy as np\n>>> from scipy.stats import Type_(name)s\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)\n\nCalculate the first four moments:\n\nType_(set_vals_stmt)s\n>>> mean, var, skew, kurt = Type_(name)s.stats(Type_(shapes)s, moments=\'mvsk\')\n\nDisplay the probability mass function (``pmf``):\n\n>>> x = np.arange(Type_(name)s.ppf(0.01, Type_(shapes)s),\n...               Type_(name)s.ppf(0.99, Type_(shapes)s))\n>>> ax.plot(x, Type_(name)s.pmf(x, Type_(shapes)s), \'bo\', ms=8, label=\'Type_(name)s pmf\')\n>>> ax.vlines(x, 0, Type_(name)s.pmf(x, Type_(shapes)s), colors=\'b\', lw=5, alpha=0.5)\n\nAlternatively, the distribution object can be called (as a function)\nto fix the shape and location. This returns a \"frozen\" RV object holding\nthe given parameters fixed.\n\nFreeze the distribution and display the frozen ``pmf``:\n\n>>> rv = Type_(name)s(Type_(shapes)s)\n>>> ax.vlines(x, 0, rv.pmf(x), colors=\'k\', linestyles=\'-\', lw=1,\n...         label=\'frozen pmf\')\n>>> ax.legend(loc=\'best\', frameon=False)\n>>> plt.show()\n\nCheck accuracy of ``cdf`` and ``ppf``:\n\n>>> prob = Type_(name)s.cdf(x, Type_(shapes)s)\n>>> np.allclose(x, Type_(name)s.ppf(prob, Type_(shapes)s))\nTrue\n\nGenerate random numbers:\n\n>>> r = Type_(name)s.rvs(Type_(shapes)s, size=1000)\n"}
._doc_default_discrete_locscale: {"The probability mass function above is defined in the \"standardized\" form.\nTo shift distribution use the ``loc`` parameter.\nSpecifically, ``Type_(name)s.pmf(k, Type_(shapes)s, loc)`` is identically\nequivalent to ``Type_(name)s.pmf(k - loc, Type_(shapes)s)``.\n"}


._doc_default_before_notes: Str

._doc_default_disc: Str



._moment: |R: Type|(data: Obj, n: R, mu: R := R) -> Never
._moment_from_stats: |R :> {3.0}, R <: Structural({.__add__ = (self: Never, ?R) -> ?O}), O <: Structural({.__mul__ = (self: Never, ?R) -> ?O}), R <: Structural({.__pow__ = (self: Never, ?R) -> ?R; .__add__ = (self: Never, ?R) -> ?O}), R: Type, O: Type|(n: {0}, mu: Obj, mu2: R, g1: Structural({.__mul__ = (self: Never, R) -> R and (self: Never, R) -> R}), g2: Structural({.__add__ = (self: Never, R) -> O}), moment_func: ({1}) -> Never, args: Obj) -> Never
._skew: (data: Obj) -> Never
._kurtosis: (data: Obj) -> Never
._vectorize_rvs_over_shapes: |Type_319292: Type|(_rvs1: (Obj, Type_319292) -> Never) -> (size: global::Indexable(Obj, Never), random_state: Obj, *args: global::List(Never, _: Nat)) -> Never
._fit_determine_optimizer: (optimizer: Str) -> Str
._isintegral: (x: Obj) -> Bool
._sum_finite: (x: global::Indexable(Obj, Never)) -> global::Tuple([Never, Never])
.Type_rv_frozen: ClassType
.Type_rv_frozen.kwds: Never
.Type_rv_frozen.args: Never
.Type_rv_frozen.dist: Never
.Type_rv_frozen.__call__: (dist: Obj, *args: Obj, **kwds := ?318600) -> _distn_infrastructure.Type_rv_frozen
.Type_rv_frozen.random_state: (self: _distn_infrastructure.Type_rv_frozen) -> Never
.Type_rv_frozen.random_state: (self: _distn_infrastructure.Type_rv_frozen, seed: Obj) -> NoneType
.Type_rv_frozen.cdf: (self: _distn_infrastructure.Type_rv_frozen, x: Obj) -> Never
.Type_rv_frozen.logcdf: (self: _distn_infrastructure.Type_rv_frozen, x: Obj) -> Never
.Type_rv_frozen.ppf: (self: _distn_infrastructure.Type_rv_frozen, q: Obj) -> Never
.Type_rv_frozen.isf: (self: _distn_infrastructure.Type_rv_frozen, q: Obj) -> Never
.Type_rv_frozen.rvs: (self: _distn_infrastructure.Type_rv_frozen, size: Obj := Obj, random_state: Obj := Obj) -> Never
.Type_rv_frozen.sf: (self: _distn_infrastructure.Type_rv_frozen, x: Obj) -> Never
.Type_rv_frozen.logsf: (self: _distn_infrastructure.Type_rv_frozen, x: Obj) -> Never
.Type_rv_frozen.stats: (self: _distn_infrastructure.Type_rv_frozen, moments: Obj := Obj) -> Never
.Type_rv_frozen.median: (self: _distn_infrastructure.Type_rv_frozen) -> Never
.Type_rv_frozen.mean: (self: _distn_infrastructure.Type_rv_frozen) -> Never
.Type_rv_frozen.var: (self: _distn_infrastructure.Type_rv_frozen) -> Never
.Type_rv_frozen.std: (self: _distn_infrastructure.Type_rv_frozen) -> Never
.Type_rv_frozen.moment: (self: _distn_infrastructure.Type_rv_frozen, order: Obj := Obj) -> Never
.Type_rv_frozen.entropy: (self: _distn_infrastructure.Type_rv_frozen) -> Never
.Type_rv_frozen.interval: (self: _distn_infrastructure.Type_rv_frozen, confidence: Obj := Obj) -> Never
.Type_rv_frozen.expect: (self: _distn_infrastructure.Type_rv_frozen, func: Obj := Obj, lb: Obj := Obj, ub: Obj := Obj, conditional: Obj := Obj, **kwds := ?318661) -> Never
.Type_rv_frozen.support: (self: _distn_infrastructure.Type_rv_frozen) -> Never

.Type_rv_discrete_frozen: ClassType
_distn_infrastructure = pyimport "_distn_infrastructure"
.Type_rv_discrete_frozen <: .Type_rv_frozen
.Type_rv_discrete_frozen.pmf: (self: _distn_infrastructure.Type_rv_discrete_frozen, k: Obj) -> Never
.Type_rv_discrete_frozen.logpmf: (self: _distn_infrastructure.Type_rv_discrete_frozen, k: Obj) -> Never

.Type_rv_continuous_frozen: ClassType
.Type_rv_continuous_frozen <: .Type_rv_frozen
.Type_rv_continuous_frozen.pdf: (self: _distn_infrastructure.Type_rv_continuous_frozen, x: Obj) -> Never
.Type_rv_continuous_frozen.logpdf: (self: _distn_infrastructure.Type_rv_continuous_frozen, x: Obj) -> Never

.argsreduce: (cond: Obj, *args: Obj) -> global::List!(Never, _: Nat)
.parse_arg_template: {"\ndef _parse_args(self, Type_(shape_arg_str)s Type_(locscale_in)s):\n    return (Type_(shape_arg_str)s), Type_(locscale_out)s\n\ndef _parse_args_rvs(self, Type_(shape_arg_str)s Type_(locscale_in)s, size=None):\n    return self._argcheck_rvs(Type_(shape_arg_str)s Type_(locscale_out)s, size=size)\n\ndef _parse_args_stats(self, Type_(shape_arg_str)s Type_(locscale_in)s, moments=\'mv\'):\n    return (Type_(shape_arg_str)s), Type_(locscale_out)s, moments\n"}
.Type_rv_generic: ClassType
.Type_rv_generic._stats_has_moments: Never
.Type_rv_generic._random_state: Never
.Type_rv_generic.__call__: (self: _distn_infrastructure.Type_rv_generic, *args: Obj, **kwds := ?318719) -> Never
.Type_rv_generic.random_state: (self: _distn_infrastructure.Type_rv_generic) -> Never
.Type_rv_generic.random_state: (self: _distn_infrastructure.Type_rv_generic, seed: Obj) -> NoneType
.Type_rv_generic.__setstate__: (self: _distn_infrastructure.Type_rv_generic, state: global::Indexable(Obj, Never)) -> Never
.Type_rv_generic._attach_methods: (self: _distn_infrastructure.Type_rv_generic) -> Never
.Type_rv_generic._attach_argparser_methods: (self: _distn_infrastructure.Type_rv_generic) -> NoneType
.Type_rv_generic._construct_argparser: |T :> NoneType, T: Type|(self: _distn_infrastructure.Type_rv_generic, meths_to_inspect: global::Iterable(T), locscale_in: Obj, locscale_out: Obj) -> NoneType or T
.Type_rv_generic._construct_doc: (self: Never, docdict: Never, shapes_vals: Obj := Obj) -> NoneType
.Type_rv_generic._construct_default_doc: (self: Never, longname: Obj := Obj, docdict: Never := Never, discrete: Obj := Obj) -> Never
.Type_rv_generic.freeze: (self: _distn_infrastructure.Type_rv_generic, *args: Obj, **kwds := ?318715) -> Never
.Type_rv_generic.__call__: (self: _distn_infrastructure.Type_rv_generic, *args: Obj, **kwds := ?318719) -> Never
.Type_rv_generic._stats: (self: _distn_infrastructure.Type_rv_generic, *args: Obj, **kwds := ?318723) -> global::Tuple([{None}, {None}, {None}, {None}])
.Type_rv_generic._munp: (self: _distn_infrastructure.Type_rv_generic, n: Obj, *args: Obj) -> Never
.Type_rv_generic._argcheck_rvs: (self: _distn_infrastructure.Type_rv_generic, *args: Obj, **kwargs := ?V) -> global::Tuple([global::List!(Structural({.shape = global::Indexable(Obj, {1}); .ndim = Structural({.__sub__ = (self: Never, Obj) -> Structural({.__lt__ = (self: Never, Obj) -> Bool; .__gt__ = (self: Never, Obj) -> Bool}); .__gt__ = (self: Never, Obj) -> Bool}); .__getitem__ = (self: Never, Obj) -> Never}), _: Nat), Structural({.shape = global::Indexable(Obj, {1}); .ndim = Structural({.__sub__ = (self: Never, Obj) -> Structural({.__lt__ = (self: Never, Obj) -> Bool; .__gt__ = (self: Never, Obj) -> Bool}); .__gt__ = (self: Never, Obj) -> Bool}); .__getitem__ = (self: Never, Obj) -> Never}), Structural({.shape = global::Indexable(Obj, {1}); .ndim = Structural({.__sub__ = (self: Never, Obj) -> Structural({.__lt__ = (self: Never, Obj) -> Bool; .__gt__ = (self: Never, Obj) -> Bool}); .__gt__ = (self: Never, Obj) -> Bool}); .__getitem__ = (self: Never, Obj) -> Never}), global::Indexable(Obj, {1}) or global::Tuple([Never])])
.Type_rv_generic._argcheck: (self: _distn_infrastructure.Type_rv_generic, *args: Obj) -> {1}
.Type_rv_generic._get_support: (self: _distn_infrastructure.Type_rv_generic, *args: Obj, **kwargs := ?318738) -> global::Tuple([Never, Never])
.Type_rv_generic._support_mask: |R <: Structural({.__le__ = (self: Never, ?R) -> Bool}), R: Type|(self: _distn_infrastructure.Type_rv_generic, x: R, *args: Obj) -> NoneType
.Type_rv_generic._open_support_mask: |R: Type, R <: Structural({.__lt__ = (self: Never, ?R) -> Bool})|(self: _distn_infrastructure.Type_rv_generic, x: R, *args: Obj) -> NoneType
.Type_rv_generic._rvs: Never
.Type_rv_generic._logcdf: (self: _distn_infrastructure.Type_rv_generic, x: Obj, *args: Obj) -> NoneType
.Type_rv_generic._sf: (self: _distn_infrastructure.Type_rv_generic, x: Obj, *args: Obj) -> Float
.Type_rv_generic._logsf: (self: _distn_infrastructure.Type_rv_generic, x: Obj, *args: Obj) -> NoneType
.Type_rv_generic._ppf: Never
.Type_rv_generic._isf: Never
.Type_rv_generic.rvs: (self: _distn_infrastructure.Type_rv_generic, *args: Obj, **kwds := ?318777) -> Int
.Type_rv_generic.stats: (self: _distn_infrastructure.Type_rv_generic, *args: Obj, **kwds := ?318781) -> Never
.Type_rv_generic.entropy: (self: _distn_infrastructure.Type_rv_generic, *args: Obj, **kwds := ?318785) -> Never
.Type_rv_generic.moment: |R: Type, R <: Structural({.__lt__ = (self: Never, ?R) -> Bool and (self: Never, ?R) -> Bool; .__gt__ = (self: Never, ?R) -> Bool})|(self: _distn_infrastructure.Type_rv_generic, order: R, *args: Obj, **kwds := ?318790) -> Never
.Type_rv_generic.median: |Type_318614: Type, Type_318793: Type|(self: Never, *args: ?318793, **kwds := ?318794) -> ?Type_318614
.Type_rv_generic.mean: |U: Type, Type_318797: Type, T: Type|(self: _distn_infrastructure.Type_rv_generic, *args: ?318797, **kwds := ?318798) -> ?U or ?T
.Type_rv_generic.var: |U: Type, Type_318801: Type, T: Type|(self: _distn_infrastructure.Type_rv_generic, *args: ?318801, **kwds := ?318802) -> ?U or ?T
.Type_rv_generic.std: |Type_318807: Type, Type_318805: Type|(self: _distn_infrastructure.Type_rv_generic, *args: ?318805, **kwds := ?318806) -> ?318807
.Type_rv_generic.interval: |Type_318809: Type, Type_318614: Type, Type_318810: Type|(self: Never, confidence: ?318809, *args: ?318810, **kwds := ?318811) -> global::Tuple([?Type_318614, ?Type_318614])
.Type_rv_generic.support: |O: Type, Type_318814: Type|(self: _distn_infrastructure.Type_rv_generic, *args: ?318814, **kwargs := ?318815) -> global::Tuple([?O, ?O])
.Type_rv_generic.nnlf: |Type_318818: Type, O: Type|(self: _distn_infrastructure.Type_rv_generic, theta: ?318818, x: Never) -> ?O
.Type_rv_generic._nnlf: |Type_318823: Type, R: Type, Type_318822: Type|(self: _distn_infrastructure.Type_rv_generic, x: ?318822, *args: ?318823) -> ?R
.Type_rv_generic._nlff_and_penalty: |Type_318827: Type, K: Type, Self <: global::Indexable(?K, ?V), V: Type, R: Type|(self: _distn_infrastructure.Type_rv_generic, x: Never, args: ?318827, log_fitfun: (Never) -> ?Self) -> ?R
.Type_rv_generic._penalized_nnlf: |Type_318832: Type, Type_318831: Type, O: Type|(self: _distn_infrastructure.Type_rv_generic, theta: ?318831, x: ?318832) -> ?O
.Type_rv_generic._penalized_nlpsf: |R: Type, Type_318835: Type|(self: _distn_infrastructure.Type_rv_generic, theta: ?318835, x: Never) -> ?R

.Type__ShapeInfo: ClassType
.Type__ShapeInfo.domain: Never
.Type__ShapeInfo.integrality: Never
.Type__ShapeInfo.name: Never
.Type__ShapeInfo.__call__: (name: Obj, integrality: Obj := Obj, domain: Obj := Obj, inclusive: Obj := Obj) -> _distn_infrastructure.Type__ShapeInfo

._get_fixed_fit_value: |T <: Nat, T :> {Type_v_global_179: Int | (Type_v_global_179 >= 0) and (Type_v_global_179 <= 255)} or ?T, T: Type|(kwds: Never, names: global::Iterable(T)) -> {None} or T
.rv_continuous: ClassType

._drv2_moment: (self: Obj, n: Obj, *args: Obj) -> Float
._drv2_ppfsingle: (self: _distn_infrastructure.Type_rv_generic, q: Nat, *args: Obj) -> NoneType
.rv_discrete: ClassType

._expect: |R :> {1000}, R <: Float, O <: global::Num, R :> {0}, R <: Structural({.__neg__ = (self: Never) -> ?R}), Type_318614 <: Structural({.__sub__ = (self: Never, ?R) -> ?Type_318614 and (self: Never, ?R) -> ?R; .__gt__ = (self: Never, Never) -> Bool; .__lt__ = (self: Never, ?Type_318614) -> Bool}), R: Type, Type_318614: Type|(fun: (x: Obj) -> Never, lb: Type_318614, ub: Never, x0: Type_318614, inc: R, maxcount: {1000} := R and {1000}, tolerance: {0.0000000001} := {0.0000000001} and {0.0000000001}, chunksize: {32} := Structural({.__le__ = (self: Never, R) -> Bool; .__mul__ = (self: Never, R) -> O}) and {32}) -> Float
._iter_chunked: |R <: Nat, R <: Float, R <: Structural({.__neg__ = (self: Never) -> ?R}), Type_318614 <: Structural({.__sub__ = (self: Never, ?R) -> ?Type_318614 and (self: Never, ?R) -> ?R; .__gt__ = (self: Never, Never) -> Bool; .__lt__ = (self: Never, ?Type_318614) -> Bool}), R: Type, Type_318614: Type|(x0: Type_318614, x1: R, chunksize: {32} := {4} and {32}, inc: R := {1} and R) -> global::Iterable(Structural({.size = R and R}))
.rv_sample: ClassType

._check_shape: |K: Type, T: Type, Type_323188: Type, V: Type, Self <: global::Indexable(?K, ?V), T <: Structural({.__gt__ = (self: Never, ?R) -> Bool}), Type_323189: Type, Self :> global::Tuple([global::Tuple([T]), global::Tuple([?T])]), Self <: global::Indexable(?K, ?V), Type_318878 <: Structural({.__getitem__ = (self: Obj, ?323188) -> ?323189}), R: Type|(argshape: Type_318878, size: Self) -> Self
.get_distribution_names: (namespace_pairs: global::Iterable(global::Indexable(Obj, Never)), rv_base_class: global::HomogenousTuple(ClassType) or ClassType) -> global::Tuple([global::List!(Never, 1), global::List!(Never, 1)])
