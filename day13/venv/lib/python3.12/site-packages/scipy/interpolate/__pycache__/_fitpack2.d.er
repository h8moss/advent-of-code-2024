##[pylyzer] failed /home/dani/advent-of-code-2024/day13/venv/lib/python3.12/site-packages/scipy/interpolate/_fitpack2.py 1734628983 89166

.__all__: global::List!({"InterpolatedUnivariateSpline", "BivariateSpline", "SmoothSphereBivariateSpline", "UnivariateSpline", "RectBivariateSpline", "RectSphereBivariateSpline", "LSQUnivariateSpline", "SmoothBivariateSpline", "LSQBivariateSpline", "LSQSphereBivariateSpline"}, 10)
.warnings = pyimport "<failure>"
.<failure> = pyimport "<failure>"

.___v_desugar_1 = pyimport "__init__"
.__init__ = pyimport "__init__"
.zeros: Never
.concatenate: Never
.ravel: Never
.diff: Never
.array: Never
.np = pyimport "__init__"


.___v_desugar_2 = pyimport "__init__"

._fitpack_impl: Never
.___v_desugar_3 = pyimport "__init__"

.dfitpack: Never
.dfitpack_int: Never
._curfit_messages: global::Dict!({{1}: {"\nThe required storage space exceeds the available storage space, as\nspecified by the parameter nest: nest too small. If nest is already\nlarge (say nest > m.2), it may also indicate that s is too small.\nThe approximation returned is the weighted least-squares spline\naccording to the knots t[0],t[1],...,t[n-1]. (n=nest) the parameter fp\ngives the corresponding weighted sum of squared residuals (fp>s).\n"}, {3}: {"\nThe maximal number of iterations maxit (set to 20 by the program)\nallowed for finding a smoothing spline with fp=s has been reached: s\ntoo small.\nThere is an approximation returned but the corresponding weighted sum\nof squared residuals does not satisfy the condition abs(fp-s).s < tol."}, {2}: {"\nA theoretically impossible result was found during the iteration\nprocess for finding a smoothing spline with fp = s: s too small.\nThere is an approximation returned but the corresponding weighted sum\nof squared residuals does not satisfy the condition abs(fp-s).s < tol."}, {10}: {"\nError on entry, no approximation returned. The following conditions\nmust hold:\nxb<=x[0]<x[1]<...<x[m-1]<=xe, w[i]>0, i=0..m-1\nif iopt=-1:\n  xb<t[k+1]<t[k+2]<...<t[n-k-2]<xe"}})
._extrap_modes: global::Dict!({{1}: {1}, {"raise"}: {2}, {"zeros"}: {1}, {2}: {2}, {3}: {3}, {0}: {0}, {"extrapolate"}: {0}, {"const"}: {3}})
.UnivariateSpline: ClassType
.UnivariateSpline._data: Never
.UnivariateSpline.__call__: (self: _fitpack2.UnivariateSpline, x: Obj, nu: Obj := Obj, ext: Obj := Obj) -> Never
.UnivariateSpline.validate_input: |R <: Float, Type_298818: Type, T :> {1}, R: Type, Type_298821 <: Structural({.__gt__ = (self: Never, ?R) -> Bool; .__ge__ = (self: Never, ?R) -> Bool})|(x: Obj, y: Obj, w: Type_298818, bbox: Obj, k: R, s: Type_298821, ext: T, check_finite: Bool) -> global::Tuple([Never, Never, Type_298818, Never, T])
.UnivariateSpline._from_tck: (cls: Obj, tck: global::Indexable(Obj, Structural({.__len__ = (self: Never) -> Nat})), ext: Obj := Obj) -> Never
.UnivariateSpline._reset_class: (self: _fitpack2.UnivariateSpline) -> NoneType
.UnivariateSpline._set_class: (self: _fitpack2.UnivariateSpline, cls: ClassType) -> NoneType
.UnivariateSpline._reset_nest: (self: _fitpack2.UnivariateSpline, data: global::Indexable(Obj, Never), nest: Obj := Obj) -> Never
.UnivariateSpline.set_smoothing_factor: (self: _fitpack2.UnivariateSpline, s: Obj) -> Never
.UnivariateSpline.__call__: (self: _fitpack2.UnivariateSpline, x: Obj, nu: Obj := Obj, ext: Obj := Obj) -> Never
.UnivariateSpline.get_knots: (self: _fitpack2.UnivariateSpline) -> Never
.UnivariateSpline.get_coeffs: (self: _fitpack2.UnivariateSpline) -> Never
.UnivariateSpline.get_residual: (self: _fitpack2.UnivariateSpline) -> Never
.UnivariateSpline.integral: (self: _fitpack2.UnivariateSpline, a: Obj, b: Obj) -> Never
.UnivariateSpline.derivatives: (self: _fitpack2.UnivariateSpline, x: Obj) -> Never
.UnivariateSpline.roots: (self: _fitpack2.UnivariateSpline) -> Never
.UnivariateSpline.derivative: (self: _fitpack2.UnivariateSpline, n: Obj := Obj) -> Never
.UnivariateSpline.antiderivative: (self: _fitpack2.UnivariateSpline, n: Obj := Obj) -> Never

.InterpolatedUnivariateSpline: ClassType
_fitpack2 = pyimport "_fitpack2"
.InterpolatedUnivariateSpline <: .UnivariateSpline
.InterpolatedUnivariateSpline._data: Never
.InterpolatedUnivariateSpline.__call__: (x: Obj, y: Obj, w: Obj := Obj, bbox: Obj := Obj, k: Obj := Obj, ext: Obj := Obj, check_finite: Obj := Obj) -> _fitpack2.InterpolatedUnivariateSpline

._fpchec_error_string: {"The input parameters have been rejected by fpchec. This means that at least one of the following conditions is violated:\n\n1) k+1 <= n-k-1 <= m\n2) t(1) <= t(2) <= ... <= t(k+1)\n   t(n-k) <= t(n-k+1) <= ... <= t(n)\n3) t(k+1) < t(k+2) < ... < t(n-k)\n4) t(k+1) <= x(i) <= t(n-k)\n5) The conditions specified by Schoenberg and Whitney must hold\n   for at least one subset of data points, i.e., there must be a\n   subset of data points y(j) such that\n       t(j) < y(j) < t(j+k+1), j=1,2,...,n-k-1\n"}
.LSQUnivariateSpline: ClassType
.LSQUnivariateSpline <: .UnivariateSpline
.LSQUnivariateSpline._data: Never
.LSQUnivariateSpline.__call__: (x: Obj, y: Obj, t: Obj, w: Obj := Obj, bbox: Obj := Obj, k: Obj := Obj, ext: Obj := Obj, check_finite: Obj := Obj) -> _fitpack2.LSQUnivariateSpline

.Type__BivariateSplineBase: ClassType
.Type__BivariateSplineBase.__call__: |R: Type|(self: _fitpack2.Type__BivariateSplineBase, x: Obj, y: Obj, dx: Structural({.__or__ = (self: Never, R) -> Bool}) := Structural({.__or__ = (self: Never, R) -> Bool}), dy: R := R, grid: Bool := Bool) -> Never
.Type__BivariateSplineBase._from_tck: |Type_299981: Type, Type_299982: Type, Type_298900 <: Structural({.__len__ = (self: Never) -> Nat; .__getitem__ = (self: Obj, ?299981) -> ?299982 and (self: Obj, ?299983) -> ?299984}), Type_299984: Type, Type_299983: Type|(cls: Obj, tck: Type_298900) -> Never
.Type__BivariateSplineBase.get_residual: (self: _fitpack2.Type__BivariateSplineBase) -> Never
.Type__BivariateSplineBase.get_knots: (self: _fitpack2.Type__BivariateSplineBase) -> Never
.Type__BivariateSplineBase.get_coeffs: (self: _fitpack2.Type__BivariateSplineBase) -> Never
.Type__BivariateSplineBase.__call__: |R: Type|(self: _fitpack2.Type__BivariateSplineBase, x: Obj, y: Obj, dx: Structural({.__or__ = (self: Never, R) -> Bool}) := Structural({.__or__ = (self: Never, R) -> Bool}), dy: R := R, grid: Bool := Bool) -> Never
.Type__BivariateSplineBase.partial_derivative: (self: _fitpack2.Type__BivariateSplineBase, dx: {0}, dy: {0}) -> Never

._surfit_messages: global::Dict!({{4}: {"\nNo more knots can be added because the number of b-spline coefficients\n(nx-kx-1)*(ny-ky-1) already exceeds the number of data points m:\neither s or m too small.\nThe weighted least-squares spline corresponds to the current set of\nknots."}, {1}: {"\nThe required storage space exceeds the available storage space: nxest\nor nyest too small, or s too small.\nThe weighted least-squares spline corresponds to the current set of\nknots."}, Int: {"\nThe coefficients of the spline returned have been computed as the\nminimal norm least-squares solution of a (numerically) rank deficient\nsystem (deficiency=Type_i). If deficiency is large, the results may be\ninaccurate. Deficiency may strongly depend on the value of eps."}, {3}: {"\nthe maximal number of iterations maxit (set to 20 by the program)\nallowed for finding a smoothing spline with fp=s has been reached:\ns too small.\nWeighted sum of squared residuals does not satisfy abs(fp-s).s < tol."}, {5}: {"\nNo more knots can be added because the additional knot would (quasi)\ncoincide with an old one: s too small or too large a weight to an\ninaccurate data point.\nThe weighted least-squares spline corresponds to the current set of\nknots."}, {10}: {"\nError on entry, no approximation returned. The following conditions\nmust hold:\nxb<=x[i]<=xe, yb<=y[i]<=ye, w[i]>0, i=0..m-1\nIf iopt==-1, then\n  xb<tx[kx+1]<tx[kx+2]<...<tx[nx-kx-2]<xe\n  yb<ty[ky+1]<ty[ky+2]<...<ty[ny-ky-2]<ye"}, {2}: {"\nA theoretically impossible result was found during the iteration\nprocess for finding a smoothing spline with fp = s: s too small or\nbadly chosen eps.\nWeighted sum of squared residuals does not satisfy abs(fp-s).s < tol."}})
.BivariateSpline: ClassType
.BivariateSpline <: .Type__BivariateSplineBase
.BivariateSpline.ev: (self: _fitpack2.BivariateSpline, xi: Obj, yi: Obj, dx: Obj := Obj, dy: Obj := Obj) -> Never
.BivariateSpline.integral: (self: _fitpack2.BivariateSpline, xa: Obj, xb: Obj, ya: Obj, yb: Obj) -> Never
.BivariateSpline._validate_input: |Type_298941 <: Structural({.__add__ = (self: Never, ?R) -> ?O}), R <: Float, R :> {1}, Type_298940: Type, R: Type, O: Type|(x: Obj, y: Obj, z: Obj, w: Type_298940, kx: Type_298941, ky: Structural({.__add__ = (self: Never, R) -> R}), eps: R) -> global::Tuple([Never, Never, Never, Type_298940])

._DerivedBivariateSpline: ClassType

.SmoothBivariateSpline: ClassType
.SmoothBivariateSpline <: .BivariateSpline
.SmoothBivariateSpline.degrees: Never
.SmoothBivariateSpline.fp: Never
.SmoothBivariateSpline.tck: Never
.SmoothBivariateSpline.__call__: (x: Obj, y: Obj, z: Obj, w: Obj := Obj, bbox: Obj := Obj, kx: Obj := Obj, ky: Obj := Obj, s: Obj := Obj, eps: Obj := Obj) -> _fitpack2.SmoothBivariateSpline

.LSQBivariateSpline: ClassType
.LSQBivariateSpline <: .BivariateSpline
.LSQBivariateSpline.degrees: Never
.LSQBivariateSpline.fp: Never
.LSQBivariateSpline.tck: Never
.LSQBivariateSpline.__call__: (x: Obj, y: Obj, z: Obj, tx: Obj, ty: Obj, w: Obj := Obj, bbox: Obj := Obj, kx: Obj := Obj, ky: Obj := Obj, eps: Obj := Obj) -> _fitpack2.LSQBivariateSpline

.RectBivariateSpline: ClassType
.RectBivariateSpline <: .BivariateSpline
.RectBivariateSpline.degrees: Never
.RectBivariateSpline.fp: Never
.RectBivariateSpline.tck: Never
.RectBivariateSpline.__call__: (x: Obj, y: Obj, z: Obj, bbox: Obj := Obj, kx: Obj := Obj, ky: Obj := Obj, s: Obj := Obj) -> _fitpack2.RectBivariateSpline

._spherefit_messages: global::Dict({{4}: {"\nNo more knots can be added because the number of b-spline coefficients\n(nx-kx-1)*(ny-ky-1) already exceeds the number of data points m:\neither s or m too small.\nThe weighted least-squares spline corresponds to the current set of\nknots."}, {1}: {"\nThe required storage space exceeds the available storage space: nxest\nor nyest too small, or s too small.\nThe weighted least-squares spline corresponds to the current set of\nknots."}, Int: {"\nThe coefficients of the spline returned have been computed as the\nminimal norm least-squares solution of a (numerically) rank deficient\nsystem (deficiency=Type_i). If deficiency is large, the results may be\ninaccurate. Deficiency may strongly depend on the value of eps."}, {3}: {"\nthe maximal number of iterations maxit (set to 20 by the program)\nallowed for finding a smoothing spline with fp=s has been reached:\ns too small.\nWeighted sum of squared residuals does not satisfy abs(fp-s).s < tol."}, {5}: {"\nNo more knots can be added because the additional knot would (quasi)\ncoincide with an old one: s too small or too large a weight to an\ninaccurate data point.\nThe weighted least-squares spline corresponds to the current set of\nknots."}, {10}: {"\nError on entry, no approximation returned. The following conditions\nmust hold:\nxb<=x[i]<=xe, yb<=y[i]<=ye, w[i]>0, i=0..m-1\nIf iopt==-1, then\n  xb<tx[kx+1]<tx[kx+2]<...<tx[nx-kx-2]<xe\n  yb<ty[ky+1]<ty[ky+2]<...<ty[ny-ky-2]<ye"}, {2}: {"\nA theoretically impossible result was found during the iteration\nprocess for finding a smoothing spline with fp = s: s too small or\nbadly chosen eps.\nWeighted sum of squared residuals does not satisfy abs(fp-s).s < tol."}})


.SphereBivariateSpline: ClassType
.SphereBivariateSpline <: .Type__BivariateSplineBase
.SphereBivariateSpline.__call__: (self: _fitpack2.SphereBivariateSpline, theta: Obj, phi: Obj, dtheta: Obj := Obj, dphi: Obj := Obj, grid: Obj := Obj) -> Never
.SphereBivariateSpline.ev: (self: _fitpack2.SphereBivariateSpline, theta: Obj, phi: Obj, dtheta: Obj := Obj, dphi: Obj := Obj) -> Never

.SmoothSphereBivariateSpline: ClassType
.SmoothSphereBivariateSpline <: .SphereBivariateSpline
.SmoothSphereBivariateSpline.degrees: Never
.SmoothSphereBivariateSpline.fp: Never
.SmoothSphereBivariateSpline.tck: Never
.SmoothSphereBivariateSpline.__call__: (self: _fitpack2.SmoothSphereBivariateSpline, theta: Obj, phi: Obj, dtheta: Obj := Obj, dphi: Obj := Obj, grid: Obj := Obj) -> Never
.SmoothSphereBivariateSpline.__call__: (self: _fitpack2.SmoothSphereBivariateSpline, theta: Obj, phi: Obj, dtheta: Obj := Obj, dphi: Obj := Obj, grid: Obj := Obj) -> Never

.LSQSphereBivariateSpline: ClassType
.LSQSphereBivariateSpline <: .SphereBivariateSpline
.LSQSphereBivariateSpline.degrees: Never
.LSQSphereBivariateSpline.fp: Never
.LSQSphereBivariateSpline.tck: Never
.LSQSphereBivariateSpline.__call__: (self: _fitpack2.LSQSphereBivariateSpline, theta: Obj, phi: Obj, dtheta: Obj := Obj, dphi: Obj := Obj, grid: Obj := Obj) -> Never
.LSQSphereBivariateSpline.__call__: (self: _fitpack2.LSQSphereBivariateSpline, theta: Obj, phi: Obj, dtheta: Obj := Obj, dphi: Obj := Obj, grid: Obj := Obj) -> Never

._spfit_messages: global::Dict({{4}: {"\nNo more knots can be added because the number of b-spline coefficients\n(nx-kx-1)*(ny-ky-1) already exceeds the number of data points m:\neither s or m too small.\nThe weighted least-squares spline corresponds to the current set of\nknots."}, {1}: {"\nThe required storage space exceeds the available storage space: nxest\nor nyest too small, or s too small.\nThe weighted least-squares spline corresponds to the current set of\nknots."}, Int: {"\nThe coefficients of the spline returned have been computed as the\nminimal norm least-squares solution of a (numerically) rank deficient\nsystem (deficiency=Type_i). If deficiency is large, the results may be\ninaccurate. Deficiency may strongly depend on the value of eps."}, {3}: {"\nthe maximal number of iterations maxit (set to 20 by the program)\nallowed for finding a smoothing spline with fp=s has been reached:\ns too small.\nWeighted sum of squared residuals does not satisfy abs(fp-s).s < tol."}, {5}: {"\nNo more knots can be added because the additional knot would (quasi)\ncoincide with an old one: s too small or too large a weight to an\ninaccurate data point.\nThe weighted least-squares spline corresponds to the current set of\nknots."}, {10}: {"\nError on entry, no approximation returned. The following conditions\nmust hold:\nxb<=x[i]<=xe, yb<=y[i]<=ye, w[i]>0, i=0..m-1\nIf iopt==-1, then\n  xb<tx[kx+1]<tx[kx+2]<...<tx[nx-kx-2]<xe\n  yb<ty[ky+1]<ty[ky+2]<...<ty[ny-ky-2]<ye"}, {2}: {"\nA theoretically impossible result was found during the iteration\nprocess for finding a smoothing spline with fp = s: s too small or\nbadly chosen eps.\nWeighted sum of squared residuals does not satisfy abs(fp-s).s < tol."}})

.RectSphereBivariateSpline: ClassType
.RectSphereBivariateSpline <: .SphereBivariateSpline
.RectSphereBivariateSpline.tck: Never
.RectSphereBivariateSpline.degrees: Never
.RectSphereBivariateSpline.fp: Never
.RectSphereBivariateSpline.v0: Never
.RectSphereBivariateSpline.__call__: (self: _fitpack2.RectSphereBivariateSpline, theta: Obj, phi: Obj, dtheta: Obj := Obj, dphi: Obj := Obj, grid: Obj := Obj) -> Never
.RectSphereBivariateSpline.__call__: (self: _fitpack2.RectSphereBivariateSpline, theta: Obj, phi: Obj, dtheta: Obj := Obj, dphi: Obj := Obj, grid: Obj := Obj) -> Never

