##[pylyzer] failed /home/dani/advent-of-code-2024/day13/venv/lib/python3.12/site-packages/scipy/optimize/_constraints.py 1734628983 22854

.np = pyimport "__init__"
.__init__ = pyimport "__init__"

.___v_desugar_1 = pyimport "_hessian_update_strategy"
._hessian_update_strategy = pyimport "_hessian_update_strategy"
.BFGS: {_hessian_update_strategy.BFGS}
.___v_desugar_2 = pyimport "_differentiable_functions"
._differentiable_functions = pyimport "_differentiable_functions"
.VectorFunction: {scipy.optimize._differentiable_functions.VectorFunction}
.LinearVectorFunction: {scipy.optimize._differentiable_functions.LinearVectorFunction}
.IdentityVectorFunction: {scipy.optimize._differentiable_functions.IdentityVectorFunction}
.___v_desugar_3 = pyimport "_optimize"
._optimize = pyimport "_optimize"
.OptimizeWarning: Never
.___v_desugar_4 = pyimport "<failure>"
.<failure> = pyimport "<failure>"
.warn: Never
.catch_warnings: Never
.simplefilter: Never
.filterwarnings: Never
.___v_desugar_5 = pyimport "__init__"

.issparse: Never
._arr_to_scalar: (x: Obj) -> Never
.NonlinearConstraint: ClassType
.NonlinearConstraint.finite_diff_jac_sparsity: Never
.NonlinearConstraint.jac: Never
.NonlinearConstraint.lb: Never
.NonlinearConstraint.keep_feasible: Never
.NonlinearConstraint.ub: Never
.NonlinearConstraint.finite_diff_rel_step: Never
.NonlinearConstraint.hess: Never
.NonlinearConstraint.fun: Never
.NonlinearConstraint.__call__: (fun: Obj, lb: Obj, ub: Obj, jac: Obj := Obj, hess: Obj := Obj, keep_feasible: Obj := Obj, finite_diff_rel_step: Obj := Obj, finite_diff_jac_sparsity: Obj := Obj) -> _constraints.NonlinearConstraint

.LinearConstraint: ClassType
.LinearConstraint.lb: Never
.LinearConstraint.keep_feasible: Never
.LinearConstraint.ub: Never
.LinearConstraint.__call__: (A: Obj, lb: Obj := Obj, ub: Obj := Obj, keep_feasible: Obj := Obj) -> _constraints.LinearConstraint
.LinearConstraint._input_validation: (self: _constraints.LinearConstraint) -> Never
.LinearConstraint.residual: (self: _constraints.LinearConstraint, x: Obj) -> global::Tuple([Never, Never])

.Bounds: ClassType
.Bounds.lb: Never
.Bounds.keep_feasible: Never
.Bounds.ub: Never
.Bounds.__call__: (lb: Obj := Obj, ub: Obj := Obj, keep_feasible: Obj := Obj) -> _constraints.Bounds
.Bounds._input_validation: (self: _constraints.Bounds) -> Never
.Bounds.__repr__: (self: _constraints.Bounds) -> Str
.Bounds.residual: |R <: Structural({.__sub__ = (self: Never, ?R) -> ?O}), R: Type, O: Type|(self: _constraints.Bounds, x: R) -> global::Tuple([O, O])

.PreparedConstraint: ClassType
.PreparedConstraint.keep_feasible: Never
.PreparedConstraint.fun: Never
.PreparedConstraint.bounds: Never
.PreparedConstraint.__call__: (constraint: Obj, x0: Obj, sparse_jacobian: Obj := Obj, finite_diff_bounds: Obj := Obj) -> _constraints.PreparedConstraint
.PreparedConstraint.violation: (self: _constraints.PreparedConstraint, x: Obj) -> Never

.new_bounds_to_old: |T :> global::Tuple([?T, ?U]), T: Type, U: Type|(lb: Obj, ub: Obj, n: Obj) -> global::List!(T, _: Nat)
.old_bound_to_new: (bounds: Obj) -> global::Tuple([Never, Never])
.strict_bounds: (lb: Obj, ub: Obj, keep_feasible: Obj, n_vars: Obj) -> global::Tuple([Never, Never])
.new_constraint_to_old: |Type_221990 <: Structural({.keep_feasible = ?224072; .A = ?Type_224091}), Type_224072: Type, Type_224091 <: {<failure>}|(con: Type_221990, x0: Structural({.__len__ = (self: Never) -> Nat})) -> global::List!(Never, _: Nat + _: Nat)
.old_constraint_to_new: (ic: Obj, con: Never) -> _constraints.NonlinearConstraint
