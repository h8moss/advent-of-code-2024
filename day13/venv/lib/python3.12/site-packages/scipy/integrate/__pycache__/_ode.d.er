##[pylyzer] failed /home/dani/advent-of-code-2024/day13/venv/lib/python3.12/site-packages/scipy/integrate/_ode.py 1734628983 48073

.__all__: global::List!({"ode", "complex_ode"}, 2)
.re = pyimport "<failure>"
.<failure> = pyimport "<failure>"

.warnings = pyimport "<failure>"


.___v_desugar_1 = pyimport "__init__"
.__init__ = pyimport "__init__"
.asarray: Never
.array: Never
.zeros: Never
.isscalar: Never
.real: Never
.imag: Never
.vstack: Never
.___v_desugar_2 = pyimport "__init__"

._vode: Never
.___v_desugar_3 = pyimport "__init__"

._dop: Never
.___v_desugar_4 = pyimport "__init__"

._lsoda: Never
._dop_int_dtype: Never
._vode_int_dtype: Never
._lsoda_int_dtype: Never
.Type_ode: ClassType
.Type_ode.jac: Never
.Type_ode.f_params: Never
.Type_ode.jac_params: Never
.Type_ode._y: Never
.Type_ode.stiff: Never
.Type_ode.f: Never
.Type_ode.__call__: (f: Obj, jac: Obj := Obj) -> _ode.Type_ode
.Type_ode.y: (self: _ode.Type_ode) -> Never
.Type_ode.set_initial_value: |T <: _ode.Type_ode|(self: T, y: Obj, t: Obj := Obj) -> T
.Type_ode.set_integrator: |T <: _ode.Type_ode|(self: T, name: Obj, **integrator_params := ?310072) -> T
.Type_ode.integrate: |R: Type, O <: Bool|(self: _ode.Type_ode, t: Obj, step: Structural({.__and__ = (self: Never, R) -> O}) := {False} and Structural({.__and__ = (self: Never, R) -> O}), relax: Structural({.__and__ = (self: Never, R) -> O}) := {False} and Structural({.__and__ = (self: Never, R) -> O})) -> Never
.Type_ode.successful: (self: _ode.Type_ode) -> {.self._integrator.success in {1}}
.Type_ode.get_return_code: (self: _ode.Type_ode) -> Never
.Type_ode.set_f_params: |Type_310085 <: _ode.Type_ode|(self: Type_310085, *args: Never) -> Type_310085
.Type_ode.set_jac_params: |Type_310088 <: _ode.Type_ode|(self: Type_310088, *args: Never) -> Type_310088
.Type_ode.set_solout: (self: _ode.Type_ode, solout: Obj) -> NoneType

._transform_banded_jac: |Type_310560: Type, K: Type, Type_310094 <: Structural({.shape = ?Self and ?Self; .__getitem__ = (self: Obj, ?310557) -> ?310558 and (self: Obj, ?310560) -> ?310561}), V: Type, Type_310558: Type, Self <: global::Indexable(?K, ?V), Self <: global::Indexable(?K, ?V), Type_310557: Type, Type_310561: Type|(bjac: Type_310094) -> Never
.Type_complex_ode: ClassType
_ode = pyimport "_ode"
.Type_complex_ode <: .Type_ode
.Type_complex_ode.cf: Never
.Type_complex_ode.cjac: Never
.Type_complex_ode.__call__: (f: Obj, jac: Obj := Obj) -> _ode.Type_complex_ode
.Type_complex_ode._wrap: (self: _ode.Type_complex_ode, t: Obj, y: global::Indexable(Obj, Structural({.__add__ = (self: Never, Obj) -> Never})), *f_args: Obj) -> Never
.Type_complex_ode._wrap_jac: (self: _ode.Type_complex_ode, t: Obj, y: global::Indexable(Obj, Structural({.__add__ = (self: Never, Obj) -> Never})), *jac_args: Obj) -> Never
.Type_complex_ode.y: (self: _ode.Type_complex_ode) -> Never
.Type_complex_ode.set_integrator: (self: _ode.Type_complex_ode, name: Obj, **integrator_params := NoneType) -> Never
.Type_complex_ode.set_initial_value: (self: _ode.Type_complex_ode, y: Obj, t: Obj := Obj) -> Never
.Type_complex_ode.integrate: (self: _ode.Type_complex_ode, t: Obj, step: Obj := Obj, relax: Obj := Obj) -> Never
.Type_complex_ode.set_solout: (self: _ode.Type_complex_ode, solout: Obj) -> Never

.find_integrator: (name: Obj) -> () -> Never
.IntegratorConcurrencyError: ClassType
.IntegratorConcurrencyError <: global::RuntimeError
.IntegratorConcurrencyError.__call__: (name: Obj) -> _ode.IntegratorConcurrencyError

.IntegratorBase: ClassType
.IntegratorBase.__call__: () -> _ode.IntegratorBase
.IntegratorBase.runner: {None}
.IntegratorBase.success: {None}
.IntegratorBase.istate: {None}
.IntegratorBase.supports_run_relax: {None}
.IntegratorBase.supports_step: {None}
.IntegratorBase.supports_solout: {False}
.IntegratorBase.integrator_classes: global::List!({_ode.Type_dopri5, _ode.Type_lsoda, _ode.Type_vode}, 0)
.IntegratorBase.scalar: {Float}
.IntegratorBase.acquire_new_handle: (self: _ode.IntegratorBase) -> NoneType
.IntegratorBase.check_handle: (self: _ode.IntegratorBase) -> NoneType
.IntegratorBase.reset: (self: _ode.IntegratorBase, n: Obj, has_jac: Obj) -> {"Prepare integrator for call: allocate memory, set flags, etc.\n        n - number of equations.\n        has_jac - if user has supplied function for evaluating Jacobian.\n        "}
.IntegratorBase.run: (self: _ode.IntegratorBase, f: Obj, jac: Obj, y0: Obj, t0: Obj, t1: Obj, f_params: Obj, jac_params: Obj) -> Never
.IntegratorBase.step: (self: _ode.IntegratorBase, f: Obj, jac: Obj, y0: Obj, t0: Obj, t1: Obj, f_params: Obj, jac_params: Obj) -> Never
.IntegratorBase.run_relax: (self: _ode.IntegratorBase, f: Obj, jac: Obj, y0: Obj, t0: Obj, t1: Obj, f_params: Obj, jac_params: Obj) -> Never

._vode_banded_jac_wrapper: |Type_310894: Type, Type_310895: Type|(jacfunc: (Type_310894, Type_310895) -> Never, ml: Obj, jac_params: Obj) -> (t: Obj, y: Obj) -> Never
.Type_vode: ClassType
.Type_vode <: .IntegratorBase
.Type_vode.rtol: Never
.Type_vode.atol: Never
.Type_vode.initialized: Never
.Type_vode.order: Never
.Type_vode.first_step: Never
.Type_vode.ml: Never
.Type_vode.min_step: Never
.Type_vode.with_jacobian: Never
.Type_vode.max_step: Never
.Type_vode.mu: Never
.Type_vode.nsteps: Never
.Type_vode.success: Never
.Type_vode.__call__: (method: Obj := Obj, with_jacobian: Obj := Obj, rtol: Obj := Obj, atol: Obj := Obj, lband: Obj := Obj, uband: Obj := Obj, order: Obj := Obj, nsteps: Obj := Obj, max_step: Obj := Obj, min_step: Obj := Obj, first_step: Obj := Obj) -> _ode.Type_vode
.Type_vode.runner: {None}
.Type_vode.messages: global::Dict!({Int: {"Repeated error test failures. (Check all input.)"}})
.Type_vode.supports_run_relax: {1}
.Type_vode.supports_step: {1}
.Type_vode.active_global_handle: {0}
.Type_vode._determine_mf_and_set_bands: (self: _ode.Type_vode, has_jac: Bool) -> Nat
.Type_vode.reset: (self: _ode.Type_vode, n: Nat, has_jac: Bool) -> NoneType
.Type_vode.run: (self: _ode.Type_vode, f: Obj, jac: (Never, Never) -> Never, y0: Obj, t0: Obj, t1: Obj, f_params: Obj, jac_params: Obj) -> global::Tuple([Never, Never])
.Type_vode.step: (self: _ode.Type_vode, *args: Obj) -> global::Tuple([Never, Never])
.Type_vode.run_relax: (self: _ode.Type_vode, *args: Obj) -> global::Tuple([Never, Never])


.Type_zvode: ClassType
.Type_zvode <: .Type_vode
.Type_zvode.runner: {None}
.Type_zvode.supports_run_relax: {1}
.Type_zvode.supports_step: {1}
.Type_zvode.scalar: {Complex}
.Type_zvode.active_global_handle: {0}
.Type_zvode.reset: (self: _ode.Type_zvode, n: Never, has_jac: Bool) -> NoneType


.Type_dopri5: ClassType
.Type_dopri5 <: .IntegratorBase
.Type_dopri5.dfactor: Never
.Type_dopri5.rtol: Never
.Type_dopri5.atol: Never
.Type_dopri5.safety: Never
.Type_dopri5.beta: Never
.Type_dopri5.verbosity: Never
.Type_dopri5.first_step: Never
.Type_dopri5.max_step: Never
.Type_dopri5.success: Never
.Type_dopri5.ifactor: Never
.Type_dopri5.nsteps: Never
.Type_dopri5.__call__: (rtol: Obj := Obj, atol: Obj := Obj, nsteps: Obj := Obj, max_step: Obj := Obj, first_step: Obj := Obj, safety: Obj := Obj, ifactor: Obj := Obj, dfactor: Obj := Obj, beta: Obj := Obj, method: Obj := Obj, verbosity: Obj := Obj) -> _ode.Type_dopri5
.Type_dopri5.runner: {None}
.Type_dopri5.name: {"dopri5"}
.Type_dopri5.supports_solout: {True}
.Type_dopri5.messages: global::Dict!({{1}: {"computation successful"}, {2}: {"computation successful (interrupted by solout)"}, Int: {"input is not consistent"}})
.Type_dopri5.set_solout: (self: _ode.Type_dopri5, solout: Obj, Complex: Obj := Obj) -> NoneType
.Type_dopri5.reset: (self: _ode.Type_dopri5, n: Nat, has_jac: Obj) -> NoneType
.Type_dopri5.run: (self: _ode.Type_dopri5, f: Obj, jac: Obj, y0: Obj, t0: Obj, t1: Obj, f_params: Obj, jac_params: Obj) -> global::Tuple([Never, Never])
.Type_dopri5._solout: (self: _ode.Type_dopri5, nr: Obj, xold: Obj, x: Obj, y: global::Indexable(Obj, Structural({.__add__ = (self: Never, Obj) -> global::Indexable(Obj, Never)})), nd: Obj, icomp: Obj, con: Obj) -> Never


.Type_dop853: ClassType
.Type_dop853 <: .Type_dopri5
.Type_dop853.__call__: (rtol: Obj := Obj, atol: Obj := Obj, nsteps: Obj := Obj, max_step: Obj := Obj, first_step: Obj := Obj, safety: Obj := Obj, ifactor: Obj := Obj, dfactor: Obj := Obj, beta: Obj := Obj, method: Obj := Obj, verbosity: Obj := Obj) -> _ode.Type_dop853
.Type_dop853.runner: {None}
.Type_dop853.name: {"dop853"}
.Type_dop853.reset: (self: _ode.Type_dop853, n: Nat, has_jac: Obj) -> NoneType


.Type_lsoda: ClassType
.Type_lsoda <: .IntegratorBase
.Type_lsoda.rtol: Never
.Type_lsoda.max_hnil: Never
.Type_lsoda.first_step: Never
.Type_lsoda.max_step: Never
.Type_lsoda.ixpr: Never
.Type_lsoda.nsteps: Never
.Type_lsoda.max_order_ns: Never
.Type_lsoda.initialized: Never
.Type_lsoda.atol: Never
.Type_lsoda.max_order_s: Never
.Type_lsoda.ml: Never
.Type_lsoda.min_step: Never
.Type_lsoda.with_jacobian: Never
.Type_lsoda.mu: Never
.Type_lsoda.success: Never
.Type_lsoda.__call__: (with_jacobian: Obj := Obj, rtol: Obj := Obj, atol: Obj := Obj, lband: Obj := Obj, uband: Obj := Obj, nsteps: Obj := Obj, max_step: Obj := Obj, min_step: Obj := Obj, first_step: Obj := Obj, ixpr: Obj := Obj, max_hnil: Obj := Obj, max_order_ns: Obj := Obj, max_order_s: Obj := Obj, method: Obj := Obj) -> _ode.Type_lsoda
.Type_lsoda.runner: Never
.Type_lsoda.active_global_handle: {0}
.Type_lsoda.messages: global::Dict!({{2}: {"Integration successful."}, Int: {"Error weight became zero during problem."}})
.Type_lsoda.reset: (self: _ode.Type_lsoda, n: Nat, has_jac: Bool) -> NoneType
.Type_lsoda.run: (self: _ode.Type_lsoda, f: Obj, jac: Obj, y0: Obj, t0: Obj, t1: Obj, f_params: Obj, jac_params: Obj) -> global::Tuple([Never, Never])
.Type_lsoda.step: (self: _ode.Type_lsoda, *args: Obj) -> global::Tuple([Never, Never])
.Type_lsoda.run_relax: (self: _ode.Type_lsoda, *args: Obj) -> global::Tuple([Never, Never])


